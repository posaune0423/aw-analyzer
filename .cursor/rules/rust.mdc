---
description:
globs: *.rs
alwaysApply: false
---
## Rust

Rust でのコーディングにおける一般的なベストプラクティスをまとめます。

### 方針

- 最初に型と、それを処理する関数のシグネチャを考える
- コードのコメントとして、そのファイルがどういう仕様化を可能な限り明記する
- 実装が内部状態を持たないとき、構造体による実装を避けて関数を優先する
- 副作用を抽象するために、トレイトで外部依存を抽象し、テストではインメモリな実装で処理する

### 型の使用方針

1. 具体的な型を使用

   - `Any` や動的型付けは禁止!!!
   - `dyn Trait` の使用は必要な場合のみ、基本的にジェネリクスで解決する
   - 型エイリアスや NewType パターンを活用する

2. 型エイリアスの命名

   - 意味のある名前をつける
   - 型の意図を明確にする
   - NewType パターンで型安全性を向上させる

   ```rust
   // Good: NewType pattern for type safety
   #[derive(Debug, Clone, PartialEq, Eq)]
   pub struct UserId(String);

   #[derive(Debug, Clone)]
   pub struct UserData {
       pub id: UserId,
       pub created_at: chrono::DateTime<chrono::Utc>,
   }

   // Bad: Generic types without meaning
   type Data = String;
   ```

### エラー処理

1. 早期リターンを徹底してネストを浅く保つ
   ```rust
   // 悪い例: ネストが深い
   fn process(x: i32) -> Result<(), Error> {
       if x > 0 {
           match some_operation() {
               Ok(_) => {
                   if condition {
                       // 処理
                   } else {
                       // 別処理
                   }
               }
               Err(e) => return Err(e),
           }
       }
       Ok(())
   }

   // 良い例: 早期リターンでネストをフラットに
   fn process(x: i32) -> Result<(), Error> {
       if x <= 0 {
           return Ok(());
       }
       
       some_operation()?;
       
       if !condition {
           return Ok(());
       }
       
       // 主処理
       Ok(())
   }
   ```

2. `Result<T, E>` を用いたエラーハンドリング
   ```rust
   use thiserror::Error;

   #[derive(Error, Debug)]
   pub enum FetchError {
       #[error("Network error: {0}")]
       Network(String),
       #[error("Not found")]
       NotFound,
   }

   pub async fn fetch_data(url: &str) -> Result<Data, FetchError> {
       if url.is_empty() {
           return Err(FetchError::Network("URL is empty".to_string()));
       }
       
       let response = reqwest::get(url)
           .await
           .map_err(|e| FetchError::Network(e.to_string()))?;
       
       if response.status() == 404 {
           return Err(FetchError::NotFound);
       }
       
       let data = response
           .json::<Data>()
           .await
           .map_err(|e| FetchError::Network(e.to_string()))?;
       
       Ok(data)
   }

   async fn handle() -> Result<(), FetchError> {
       let result = fetch_data("/api").await?;
       // 成功時の処理
       Ok(())
   }
   ```

3. エラー型の設計
   - `thiserror` や `anyhow` を適切に使用
   - エラー型は明確で、コンテキスト情報を含む
   - `?` 演算子を活用してエラー伝播を簡潔に

### 実装パターン

1. 関数ベース（状態を持たない場合）

   ```rust
   // トレイト定義
   pub trait Logger {
       fn log(&self, message: &str);
   }

   // 実装
   pub struct StdoutLogger;

   impl Logger for StdoutLogger {
       fn log(&self, message: &str) {
           println!("[{}] {}", chrono::Utc::now().to_rfc3339(), message);
       }
   }
   ```

2. 構造体ベース（状態を持つ場合）

   ```rust
   use std::collections::HashMap;
   use std::time::{Duration, Instant};

   pub trait Cache<K, V> {
       fn get(&self, key: &K) -> Option<&V>;
       fn set(&mut self, key: K, value: V);
   }

   pub struct TimeBasedCache<K, V> {
       items: HashMap<K, (V, Instant)>,
       ttl: Duration,
   }

   impl<K: std::hash::Hash + Eq, V> TimeBasedCache<K, V> {
       pub fn new(ttl: Duration) -> Self {
           Self {
               items: HashMap::new(),
               ttl,
           }
       }
   }

   impl<K: std::hash::Hash + Eq, V> Cache<K, V> for TimeBasedCache<K, V> {
       fn get(&self, key: &K) -> Option<&V> {
           let (value, created_at) = self.items.get(key)?;
           if created_at.elapsed() > self.ttl {
               return None;
           }
           Some(value)
       }

       fn set(&mut self, key: K, value: V) {
           self.items.insert(key, (value, Instant::now()));
       }
   }
   ```

3. トレイトパターン（外部依存の抽象化）

   ```rust
   use std::fmt::Debug;

   // 抽象化
   pub trait Fetcher {
       type Error: Debug;
       
       async fn fetch<T>(&self, path: &str) -> Result<T, Self::Error>
       where
           T: serde::de::DeserializeOwned;
   }

   // 実装
   pub struct HttpFetcher {
       base_url: String,
       client: reqwest::Client,
   }

   impl HttpFetcher {
       pub fn new(base_url: String) -> Self {
           Self {
               base_url,
               client: reqwest::Client::new(),
           }
       }
   }

   #[derive(Debug, thiserror::Error)]
   pub enum ApiError {
       #[error("Network error: {0}")]
       Network(String),
       #[error("HTTP error: {0}")]
       Http(u16),
   }

   impl Fetcher for HttpFetcher {
       type Error = ApiError;

       async fn fetch<T>(&self, path: &str) -> Result<T, Self::Error>
       where
           T: serde::de::DeserializeOwned,
       {
           let url = format!("{}{}", self.base_url, path);
           let response = self
               .client
               .get(&url)
               .send()
               .await
               .map_err(|e| ApiError::Network(e.to_string()))?;
           
           if !response.status().is_success() {
               return Err(ApiError::Http(response.status().as_u16()));
           }
           
           response
               .json::<T>()
               .await
               .map_err(|e| ApiError::Network(e.to_string()))
       }
   }

   // 利用
   pub struct ApiClient<F: Fetcher> {
       fetcher: F,
   }

   impl<F: Fetcher> ApiClient<F> {
       pub fn new(fetcher: F) -> Self {
           Self { fetcher }
       }

       pub async fn get_user(&self, id: &str) -> Result<User, F::Error> {
           self.fetcher.fetch(&format!("/users/{}", id)).await
       }
   }
   ```

### 実装の選択基準

1. 関数を選ぶ場合

   - 単純な操作のみ
   - 内部状態が不要
   - 依存が少ない
   - テストが容易

2. 構造体を選ぶ場合

   - 内部状態の管理が必要
   - 設定やリソースの保持が必要
   - メソッド間で状態を共有
   - ライフサイクル管理が必要

3. トレイトを選ぶ場合
   - 外部依存の抽象化
   - テスト時のモック化が必要
   - 実装の詳細を隠蔽したい
   - 差し替え可能性を確保したい

### 一般的なルール

1. 依存性の注入
   - 外部依存はコンストラクタで注入
   - テスト時にモックに置き換え可能に
   - グローバルな状態を避ける

2. トレイトの設計
   - 必要最小限のメソッドを定義
   - 実装の詳細を含めない
   - プラットフォーム固有の型を避ける

3. テスト容易性
   - モックの実装を簡潔に
   - エッジケースのテストを含める
   - テストヘルパーを適切に分離

4. コードの分割
   - 単一責任の原則に従う
   - 適切な粒度でモジュール化
   - 循環参照を避ける

5. Logging
   - `println!()` や `eprintln!()` は使わず、`log` クレートや `tracing` クレートを使用してください
   - 適切なログレベル（`debug!`, `info!`, `warn!`, `error!`）を使用してください

6. エラー処理
   - `unwrap()` や `expect()` を多用しすぎないでください。必ず必要な箇所のみに使用し、エラーは `Result` で返してください
   - `Result<T, E>` を活用し、正常系エラーと思われるものは `Result` で返してください
   - 無闇にパニックを起こさず、条件分岐などを行わないでください。予期できるエラーや、エラーを使う以外に条件分岐の判断を効果的に行う方法がある場合はそちらを優先してください。

7. 早期リターンを活用しネストが深くなることを避けてください

8. Naming Convention
   - file-name: snake_case (e.g. `graph_state.rs`)
   - module-name: snake_case
   - type-name: PascalCase
   - function-name: snake_case
   - constant-name: SCREAMING_SNAKE_CASE

9. `Option` や `Result` の `?` 演算子を活用し、冗長な関数の作成などを避け、simpleな記述、readableかつsemanticな記述を心がけて下さい

10. 不要な条件の考慮や、冗長な条件分岐を避けてください。必要十分な場合の考慮を行って下さい。条件考慮にビジネスロジックが絡んだり複雑になるようであれば適切な名前で関数に切り出して下さい。

### モジュールのエクスポート

#### pub の使い分け

- `pub`: モジュール外からアクセス可能
- `pub(crate)`: クレート内からのみアクセス可能
- `pub(super)`: 親モジュールからのみアクセス可能
- 非公開: モジュール内からのみアクセス可能

#### モジュール構造

- 1つのファイル = 1つのモジュール
- 大きなモジュールは `mod.rs` で分割
- 関連する機能は同じモジュールにまとめる

### 所有権と借用

- 所有権のルールを理解し、適切に使用する
- 借用チェッカーを活用してメモリ安全性を確保
- ライフタイム注釈を適切に使用する

### パフォーマンス

- 不要なクローンを避ける
- イテレータを活用する
- 適切なデータ構造を選択する
- プロファイル結果に基づいて最適化する

### Readable Code
Readable codeに書かれていることを遵守、　**常に**読みやすいコードを書きなさい！！！
**必ず**適切なsizeのコードチャンクで改行を入れて、読みやすいコード記述を徹底して下さい！！！
